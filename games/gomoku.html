<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>äº”å­æ£‹ - æ”¯æ´1P / 2P æ¨¡å¼</title>
  <style>
    body { font-family: sans-serif; text-align: center; background: #f9f9f9; }
    canvas { background: #f0d9b5; border: 2px solid #333; margin-top: 10px; }
    #info, #instructions {
      margin: 10px auto;
      font-size: 16px;
    }
    select { font-size: 16px; margin-left: 5px; }
    #instructions {
      width: 80%;
      padding: 10px;
      background: #e0f7ff;
      border: 1px solid #a6d4f2;
      border-radius: 8px;
      text-align: left;
    }
  </style>
</head>
<body>
  <h2>âš«âšª äº”å­æ£‹éŠæˆ²ï¼ˆ1P / 2Pï¼‰</h2>

  <div id="info">
    æ¨¡å¼ï¼š
    <select id="modeSelect">
      <option value="easy">ç°¡å–®æ¨¡å¼ï¼ˆ3åˆ†å‹ï¼‰</option>
      <option value="hard">å›°é›£æ¨¡å¼ï¼ˆ5åˆ†å‹ï¼‰</option>
    </select>
    ç©å®¶æ¨¡å¼ï¼š
    <select id="playerMode">
      <option value="1p">1Pï¼ˆç©å®¶ vs é›»è…¦ï¼‰</option>
      <option value="2p">2Pï¼ˆç©å®¶ vs ç©å®¶ï¼‰</option>
    </select>
    é›»è…¦æ™ºåŠ›ï¼š
    <select id="aiSelect">
      <option value="simple">ç°¡å–®é›»è…¦</option>
      <option value="smart" selected>é€²éšé›»è…¦</option>
    </select>
    <br><br>
    âšª ç©å®¶ 1 å¾—åˆ†ï¼š<span id="playerScore">0</span> |
    âš« ç©å®¶ 2 / é›»è…¦ å¾—åˆ†ï¼š<span id="aiScore">0</span>
    <div id="turnText">è¼ªåˆ°ï¼šç©å®¶ 1ï¼ˆâšªï¼‰</div>
  </div>

  <canvas id="board" width="600" height="600"></canvas>

  <div id="instructions">
    <strong>ğŸ® éŠæˆ²æ“ä½œèªªæ˜ï¼š</strong>
    <ul>
      <li>é»æ“Šæ£‹ç›¤ä¸‹æ£‹</li>
      <li>âšª ç©å®¶ 1 å…ˆæ‰‹ï¼Œâš« ç©å®¶ 2 æˆ–é›»è…¦ç‚ºå¾Œæ‰‹</li>
      <li>äº”å­é€£ç·šå¾— 1 åˆ†ï¼Œåˆ†æ•¸ä¸é‡è¤‡è¨ˆç®—</li>
      <li>ç°¡å–®æ¨¡å¼éœ€é” 3 åˆ†ç²å‹ï¼Œå›°é›£æ¨¡å¼éœ€ 5 åˆ†</li>
    </ul>
  </div>

  <script>
    const canvas = document.getElementById("board");
    const ctx = canvas.getContext("2d");
    const size = 15;
    const cell = canvas.width / size;

    let board, scored, playerScore, aiScore, gameOver;
    let mode, aiType, playerMode;
    let currentPlayer = 'W'; // ç©å®¶ 1 å…ˆæ‰‹

    function initGame() {
      board = Array.from({ length: size }, () => Array(size).fill(null));
      scored = { W: new Set(), B: new Set() };
      playerScore = aiScore = 0;
      gameOver = false;
      currentPlayer = 'W';
      mode = document.getElementById("modeSelect").value;
      aiType = document.getElementById("aiSelect").value;
      playerMode = document.getElementById("playerMode").value;
      updateScores();
      drawBoard();
    }

    document.getElementById("modeSelect").addEventListener("change", initGame);
    document.getElementById("aiSelect").addEventListener("change", initGame);
    document.getElementById("playerMode").addEventListener("change", initGame);

    canvas.addEventListener("click", (e) => {
      if (gameOver) return;
      const x = Math.floor(e.offsetX / cell);
      const y = Math.floor(e.offsetY / cell);
      if (board[y][x]) return;

      if (playerMode === '2p') {
        board[y][x] = currentPlayer;
        checkNewLines(x, y, currentPlayer);
        currentPlayer = (currentPlayer === 'W') ? 'B' : 'W';
        updateTurnText();
      } else {
        if (currentPlayer === 'W') {
          board[y][x] = 'W';
          checkNewLines(x, y, 'W');
          currentPlayer = 'B';
          aiMove();
          currentPlayer = 'W';
        }
      }
    });

    function updateTurnText() {
      const text = playerMode === '2p'
        ? `è¼ªåˆ°ï¼š${currentPlayer === 'W' ? 'ç©å®¶ 1ï¼ˆâšªï¼‰' : 'ç©å®¶ 2ï¼ˆâš«ï¼‰'}`
        : "ä½  vs é›»è…¦";
      document.getElementById("turnText").textContent = text;
    }

    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = "#000";
      for (let i = 0; i < size; i++) {
        ctx.beginPath();
        ctx.moveTo(cell / 2, cell / 2 + i * cell);
        ctx.lineTo(canvas.width - cell / 2, cell / 2 + i * cell);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(cell / 2 + i * cell, cell / 2);
        ctx.lineTo(cell / 2 + i * cell, canvas.height - cell / 2);
        ctx.stroke();
      }

      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          if (board[y][x]) {
            ctx.beginPath();
            ctx.arc(x * cell + cell / 2, y * cell + cell / 2, cell / 3, 0, Math.PI * 2);
            ctx.fillStyle = board[y][x] === 'B' ? "black" : "white";
            ctx.fill();
            ctx.stroke();
          }
        }
      }
    }

    function updateScores() {
      document.getElementById("playerScore").textContent = playerScore;
      document.getElementById("aiScore").textContent = aiScore;
      const win = (mode === "easy" ? 3 : 5);
      if (playerScore >= win) {
        alert("ğŸ‰ ç©å®¶ 1ï¼ˆâšªï¼‰ç²å‹ï¼");
        gameOver = true;
      } else if (aiScore >= win) {
        const winner = playerMode === '2p' ? "ç©å®¶ 2ï¼ˆâš«ï¼‰" : "é›»è…¦";
        alert(`ğŸ‰ ${winner} ç²å‹ï¼`);
        gameOver = true;
      }
    }

    function keyOfLine(line) {
      return line.map(([x, y]) => `${x},${y}`).sort().join("|");
    }

    function checkNewLines(x, y, who) {
      const dirs = [
        [[1, 0], [-1, 0]],
        [[0, 1], [0, -1]],
        [[1, 1], [-1, -1]],
        [[1, -1], [-1, 1]],
      ];
      for (let [dir1, dir2] of dirs) {
        let line = [[x, y]];
        for (let [dx, dy] of [dir1, dir2]) {
          let nx = x + dx, ny = y + dy;
          while (
            nx >= 0 && ny >= 0 && nx < size && ny < size &&
            board[ny][nx] === who
          ) {
            line.push([nx, ny]);
            nx += dx;
            ny += dy;
          }
        }
        if (line.length >= 5) {
          const key = keyOfLine(line.slice(0, 5));
          if (!scored[who].has(key)) {
            scored[who].add(key);
            if (who === 'W') playerScore++;
            else aiScore++;
            updateScores();
          }
        }
      }
    }

    function aiMove() {
      if (gameOver || playerMode !== '1p') return;

      if (aiType === "simple") {
        const options = [];
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            if (!board[y][x]) options.push({ x, y });
          }
        }
        const move = options[Math.floor(Math.random() * options.length)];
        board[move.y][move.x] = 'B';
        checkNewLines(move.x, move.y, 'B');
        return;
      }

      // é€²éš AI
      let best = null;
      const score = (x, y, who) => {
        let count = 0;
        const dirs = [
          [[1, 0], [-1, 0]],
          [[0, 1], [0, -1]],
          [[1, 1], [-1, -1]],
          [[1, -1], [-1, 1]],
        ];
        for (let [d1, d2] of dirs) {
          let total = 1;
          for (let [dx, dy] of [d1, d2]) {
            let nx = x + dx, ny = y + dy;
            while (nx >= 0 && ny >= 0 && nx < size && ny < size && board[ny][nx] === who) {
              total++;
              nx += dx;
              ny += dy;
            }
          }
          if (total >= 4) count += 10;
          else count += total;
        }
        return count;
      };

      let maxScore = -1;
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          if (!board[y][x]) {
            const attack = score(x, y, 'B');
            const defend = score(x, y, 'W') * 0.9;
            const total = attack + defend - Math.abs(x - 7) - Math.abs(y - 7);
            if (total > maxScore) {
              maxScore = total;
              best = { x, y };
            }
          }
        }
      }

      if (best) {
        board[best.y][best.x] = 'B';
        checkNewLines(best.x, best.y, 'B');
      }
    }

    initGame();
    setInterval(drawBoard, 100);
  </script>
</body>
</html>
